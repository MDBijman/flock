module codegen/build

imports
  desugar
  codegen/-
  
  signatures/flock/-
  signatures/flock/desugar/-
  signatures/java/types/-
  signatures/java/classes/-
  signatures/java/expressions/-
  signatures/java/literals/-
  signatures/java/lexical/-
  signatures/java/names/-
  signatures/java/interfaces/-
  signatures/java/statements/-
  signatures/java/packages/-
  pp/metaborg-java-pp
  pp/metaborg-java-parenthesize
  
  libstratego-gpp

rules
  flo-to-java = flo-to-java-ast; java-ast-to-code
  flo-to-java-ast = desugar-all; module-to-java
  
  flo-to-cfgnode-java: m -> java:compilation-unit |[ 
  	  package org.spoofax;
  	  ~import-dec*:imports
      ~type-dec:class
    ]|
  with
    imports := <all-imports> 
  ; class := <desugar-all; ?Module(_, _, r); node-class> m

  flo-to-cfgnodeid-java: m -> java:compilation-unit |[ 
  	  package org.spoofax;
  	  ~import-dec*:imports
      ~type-dec:class
    ]|
  with
    imports := <all-imports> 
  ; class := <desugar-all; ?Module(_, _, r); node-id-class> m
  
  flo-to-cfggraph-java: m -> java:compilation-unit |[ 
      package org.spoofax;
      ~import-dec*:imports
      ~type-dec*:class
    ]|
  with
    imports := <all-imports> 
  ; class := <desugar-all; ?Module(_, _, r); graph-class(|r)> m
  
  flo-to-setutils-java: m -> java:compilation-unit |[ 
  	  package org.spoofax;
  	  ~import-dec*:imports
  	  ~type-dec*:class
    ]| 
  with 
    imports := <all-imports>
  ; class := <setutils-class>
  
  flo-to-maputils-java: m -> java:compilation-unit |[ 
  	  package org.spoofax;
  	  ~import-dec*:imports
  	  ~type-dec*:class
    ]| 
  with 
    imports := <all-imports>
  ; class := <maputils-class>
  
  flo-to-universalset-java: m -> java:compilation-unit |[ 
  	  package org.spoofax;
  	  ~import-dec*:imports
  	  ~type-dec*:class
    ]| 
  with 
    imports := <all-imports>
  ; class := <universalset-class>
  
  flo-to-property-java: m -> java:compilation-unit |[ 
  	  package org.spoofax;
  	  ~import-dec*:imports
  	  ~type-dec*:class
    ]| 
  with 
    imports := <all-imports>
  ; class := <property-class>
  
  flo-to-lattice-java: m -> java:compilation-unit |[ 
  	  package org.spoofax;
  	  ~import-dec*:imports
  	  ~type-dec*:class
    ]| 
  with 
    imports := <all-imports>
  ; class := <lattice-class>
  
  flo-to-helper-java: m -> java:compilation-unit |[ 
  	  package org.spoofax;
  	  ~import-dec*:imports
  	  ~type-dec*:class
    ]| 
  with 
    imports := <all-imports>
  ; class := <helper-class>
  
  flo-to-transfer-java: m -> java:compilation-unit |[ 
  	  package org.spoofax;
  	  ~import-dec*:imports
  	  ~type-dec*:class
    ]| 
  with 
    imports := <all-imports>
  ; class := <transfer-class>

  flo-to-analysis-java: m -> java:compilation-unit |[ 
  	  package org.spoofax;
  	  ~import-dec*:imports
  	  ~type-dec:class
    ]| 
  with 
    imports := <all-imports>
  ; class := <analyses; analysis-class>

  java-ast-to-code =
    parenthesize-metaborg-java
    ; prettyprint-metaborg-java-start-symbols
    ; !V([], <id>)
    ; box2text-string(|120)

  module-to-java: Module(name, _, r) -> java:compilation-unit |[ 
  	  package org.spoofax;
  	  ~import-dec*:imports
  	  ~type-dec*:classes
    ]| 
  where
    imports := <all-imports>
  ; classes := <concat> [
      [<main-class(|r)> name],
      <lattice-classes(|r)>,
      <transfer-classes(|r)>,
      <user-functions-class(|r)>
    ]

  main-class(|r): name -> java:type-dec |[
	  public class FlowAnalysis {
	  	public static void main(String[] args) throws IOException {
		  IStrategoTerm ast = new TAFTermReader(new TermFactory()).parseFromFile(args[0]);
		  CfgGraph graph = CfgGraph.createControlFlowGraph(ast);
		  performDataAnalysis(graph);
		  System.out.println(graph.toGraphviz());
		}
		
		public static void initNodeValue(CfgNode node) {
		  ~bstm*:value-inits
		}
		  
	    public static void initNodeTransferFunction(CfgNode node) {
	      ~bstm:stmt
	    }
	    
    	public static void performDataAnalysis(CfgNode root) {
			HashSet<CfgNode> nodeset = new HashSet<CfgNode>();
			nodeset.add(root);
			performDataAnalysis(new HashSet<CfgNode>(), nodeset);
		}
	
		public static void performDataAnalysis(Set<CfgNode> nodeset) {
			performDataAnalysis(new HashSet<CfgNode>(), nodeset);
		}
	
		public static void performDataAnalysis(CfgGraph graph) {
			performDataAnalysis(graph.roots, graph.flatten());
		}
	
		public static void performDataAnalysis(Set<CfgNode> roots, Set<CfgNode> nodeset) {
			performDataAnalysis(roots, nodeset, new HashSet<CfgNode>());
		}
	
		public static void updateDataAnalysis(Set<CfgNode> news, Set<CfgNode> dirty) {
			performDataAnalysis(new HashSet<CfgNode>(), news, dirty);
		}
	
		public static void updateDataAnalysis(Set<CfgNode> news, Set<CfgNode> dirty, long intervalBoundary) {
			performDataAnalysis(new HashSet<CfgNode>(), news, dirty, intervalBoundary);
		}
	
		public static void performDataAnalysis(Set<CfgNode> roots, Set<CfgNode> nodeset, Set<CfgNode> dirty) {
			performDataAnalysis(roots, nodeset, dirty, ~default-boundary);
		}
		      
		public static void performDataAnalysis(Set<CfgNode> roots, Set<CfgNode> nodeset, Set<CfgNode> dirty, long intervalBoundary) {
			Queue<CfgNode> worklist = new LinkedBlockingQueue<>();
			HashSet<CfgNode> inWorklist = new HashSet<>();
			for (CfgNode node : nodeset) {
				~boundary-check-node
				worklist.add(node);
				inWorklist.add(node);
				initNodeValue(node);
				initNodeTransferFunction(node);
			}
			for (CfgNode node : dirty) {
				~boundary-check-node
				worklist.add(node);
				inWorklist.add(node);
				initNodeTransferFunction(node);
			}
		 	for (CfgNode root : roots) {
		 		~boundary-check-root
		 		~root-inits
		 	}
		  	while(!worklist.isEmpty()) ~worklist-body
		}
	  }
  ]| 
  where
    boundary-check-node := <analysis-boundary-check> java:expr |[ node.interval ]|
  ; boundary-check-root := <analysis-boundary-check> java:expr |[ root.interval ]|
  ; boundary-check-successor := <analysis-boundary-check> java:expr |[ successor.interval ]|
  ; default-boundary := <analysis-default-boundary> name
  ; value-inits := <concat> [
      <retain-all(?PropDef(_, UserTypeParams(_, _))); map(propdef-to-add)> r,
	  <retain-all(?PropDef(_, _)); map(propdef-to-bottom)> r
	]
  ; stmt := <node-factory-switch> r
  ; val-setters := <get-newvalue-setters> r
  ; forward-updaters := <get-forward-updaters> r
  ; backward-updaters := <get-backward-updaters> r
  ; worklist-body := Block(<concat> [
      java:bstm* |[
	    CfgNode node = worklist.poll();
	    inWorklist.remove(node);
	    ~boundary-check-node
      ]|,
  	  val-setters,
  	  [java:bstm |[
	    for (CfgNode successor : node.children) {
	      boolean changed = false;
	      ~boundary-check-successor
	      ~*forward-updaters
	      if (changed && !inWorklist.contains(successor)) {
	        worklist.add(successor);
	        inWorklist.add(successor);
	      }
	    } 	  
  	  ]|],
	  [java:bstm |[
	  	for (CfgNode successor : node.parents) {
	      boolean changed = false;
	      ~boundary-check-successor
	      ~*backward-updaters
	      if (changed && !inWorklist.contains(successor)) {
	        worklist.add(successor);
	        inWorklist.add(successor);
	      }
	    }
  	  ]|]
    ])
  ; root-inits := Block(<retain-all(?PropDef(_, _)); map(propdef-to-init)> r)

  
  get-newvalue-setters = filter(?PropDef(_, _)); map(propdef-to-newvalue)

  propdef-to-newvalue: PropDef(name, _) -> java:bstm |[ Object ~new-name = node.getProperty(~prop-name).transfer.eval(node); ]|
  where
    new-name := $[[name]_n]
  ; prop-name := <to-string-literal> name
 
  propdef-to-bottom: PropDef(n, _) -> java:bstm |[ node.getProperty(~name).value = node.getProperty(~name).lattice.bottom(); ]|
    where name := <to-string-literal> n
                    
  propdef-to-add: PropDef(n, UserTypeParams(tname, _)) -> java:bstm |[ node.addProperty(~name, Lattices.~tname); ]|
    where name := <to-string-literal> n
                    
  propdef-to-init: PropDef(n, _) -> java:bstm |[ root.getProperty(~name).value = root.getProperty(~name).init.eval(root); ]| 
    where name := <to-string-literal> n
