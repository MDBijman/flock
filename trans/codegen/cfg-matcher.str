module codegen/cfg-matcher

imports
  codegen/util
  codegen/nodes
  codegen/graph
  codegen/helpers

  signatures/flock/-
  signatures/flock/desugar/-

  signatures/java/types/-
  signatures/java/classes/-
  signatures/java/expressions/-
  signatures/java/literals/-
  signatures/java/lexical/-
  signatures/java/names/-
  signatures/java/interfaces/-
  signatures/java/statements/-
  signatures/java/packages/-

rules

  cfg-collector-method: r -> result
  where
    root-rules := <filter(?(CFGRule(Root(), _, _)))> r;
    root-condition := <create-root-condition> root-rules;
    result := java:method-dec |[
		private static Set<CfgNode> createCfgs(IStrategoTerm term) {
			Set<CfgNode> nodes = new HashSet<>();
			if (TermUtils.isAppl(term)) {
				if (~expr:root-condition) {
					nodes.addAll(createCfg(term).getLeft());
				}
			}
			for (IStrategoTerm subterm : term.getSubterms()) {
				nodes.addAll(createCfgs(subterm));
			}
			return nodes;
		}
    ]|
        
  create-root-condition: r -> <map(extract-pattern;cfg-pattern-to-condition(|"term", [])); root-condition-to-or> r where <debug> r
  extract-pattern: CFGRule(_, pattern, _) -> pattern
  root-condition-to-or: [h] -> h
  root-condition-to-or: [h|t] -> LazyOr(h, <root-condition-to-or> t)

  cfg-matcher-method: r -> result
  where
    cfg-rules := <filter(?(CFGRule(_, _, _)))> r
  ; switch := <cfg-matcher-switch> cfg-rules
  ; result := java:method-dec |[
      private static Pair<Set<CfgNode>, Set<CfgNode>> createCfg(IStrategoTerm term) {
		Set<CfgNode> result_heads = new HashSet<>();
		Set<CfgNode> result_leaves = new HashSet<>();
		~stm:switch
		return Pair.of(result_heads, result_leaves);
  	  }
    ]|
  
  cfg-matcher-switch: r -> java |[
  	if (TermUtils.isList(term)) {
		IStrategoList list = M.list(term);
		if (list.isEmpty()) {
			return Pair.of(result_heads, result_leaves);
		}
		Pair<Set<CfgNode>, Set<CfgNode>> result = createCfg(list.head());
		result = patchIfEmpty(result);
		result_heads.addAll(result.getLeft());
		result_leaves.addAll(result.getRight());
		list = list.tail();
		while (!list.isEmpty()) {
			Pair<Set<CfgNode>, Set<CfgNode>> new_result = createCfg(list.head());
			new_result = patchIfEmpty(new_result);
			if (new_result.getLeft().isEmpty() && new_result.getRight().isEmpty()) {
				list = list.tail();
				continue;
			}
			for (CfgNode leaf : result_leaves) {
				leaf.addChild(new_result.getLeft());
			}
			result_leaves = new_result.getRight();
			list = list.tail();
		}
	} else ~else
  ]| 
  where
    else := <cfg-matcher-switch-internal> r
             
  
  cfg-matcher-switch-internal: [] -> Block([Throw(NewInstance(None(), [], Id("RuntimeException"), [], None(), [Add(Add(StringLiteral("\"Could not create CFG node for term '\""), ExpressionName(Id("term"))), StringLiteral("\"'.\""))]))])
  cfg-matcher-switch-internal: [CFGRule(_, pattern, body)|tail] -> result
  where
    condition := <cfg-pattern-to-condition(|"term", [])> pattern;
    then := <cfg-pattern-to-then(|"term", [])> (pattern, body);
    else := <cfg-matcher-switch-internal> tail;
    result := IfElse(condition, then, else)
  
  cond-same: (l, r) -> Eq(l, r)
  cond-equals: (l, r) -> InvokeQExp(l, None(), Id("equals"), [r])
  cond-type-equals(|chain, rootterm): pattern -> <cond-equals> (<chain-to-getname(|rootterm)> chain, StringLiteral(<cfg-pattern-to-typename;to-string-literal> pattern))
  cond-arity-equals(|chain, rootterm): length -> <cond-same> (InvokeQExp(<chain-to-expression(|rootterm)> chain, None(), Id("getSubtermCount"), []), Deci(<int-to-string> length))
  chain-to-expression(|rootterm): [] -> ExpressionName(Id(rootterm))
  chain-to-expression(|rootterm): [h|t] -> <chain-to-expression(|rootterm);get-subterm(|h)> t
  chain-to-getname(|rootterm): chain -> InvokeQExp(<chain-to-expression(|rootterm);to-appl> chain, None(), Id("getName"), [])
  to-appl: expr -> InvokeQExp(ExpressionName(Id("M")), None(), Id("appl"), [expr])
  to-tuple: expr -> InvokeQExp(ExpressionName(Id("M")), None(), Id("tuple"), [expr])
  extract-string: expr -> InvokeQExp(ExpressionName(Id("M")), None(), Id("string"), [expr])
  extract-int: expr -> InvokeQExp(ExpressionName(Id("M")), None(), Id("integer"), [expr])
  
  cfg-pattern-to-condition(|rootterm, bindings) = cfg-pattern-to-condition-chain(|[], rootterm, bindings);condition-chain-to-lazy-and
  condition-chain-to-lazy-and: [] -> True()
  condition-chain-to-lazy-and: [h] -> h
  condition-chain-to-lazy-and: [h|t] -> LazyAnd(h, <condition-chain-to-lazy-and> t)
  
  chainmap(f|chain, rootterm, bindings) = number(id);map(chainmap-internal(f|chain, rootterm, bindings));concat
  chainmap-internal(f|chain, rootterm, bindings): (p, i) -> <f(|[i|chain], rootterm, bindings)> p
  
  cfg-pattern-to-condition-chain(|chain, rootterm, bindings): PropPatternEnd(x) -> <cfg-pattern-to-condition-chain(|chain, rootterm, bindings)> x
  cfg-pattern-to-condition-chain(|chain, rootterm, bindings): PropPatternStart(x) -> <cfg-pattern-to-condition-chain(|chain, rootterm, bindings)> x
  cfg-pattern-to-condition-chain(|chain, rootterm, bindings): Backward(x, _) -> <cfg-pattern-to-condition-chain(|chain, rootterm, bindings)> x
  cfg-pattern-to-condition-chain(|chain, rootterm, bindings): Forward(_, x) -> <cfg-pattern-to-condition-chain(|chain, rootterm, bindings)> x
  cfg-pattern-to-condition-chain(|chain, rootterm, bindings): At(_, x) -> <cfg-pattern-to-condition-chain(|chain, rootterm, bindings)> x
  cfg-pattern-to-condition-chain(|chain, rootterm, bindings): PatternVar(var) -> <var-equals-or-ignore(|chain, rootterm, var)> bindings
  cfg-pattern-to-condition-chain(|chain, rootterm, bindings): PatternWildcard(_) -> []
  cfg-pattern-to-condition-chain(|chain, rootterm, bindings): PatternLiteral(StringLiteral(x)) -> [<cond-equals> (<chain-to-expression(|rootterm);extract-string> chain, StringLiteral(x))]
  cfg-pattern-to-condition-chain(|chain, rootterm, bindings): PatternLiteral(IntLiteral(x)) -> [<cond-same> (<chain-to-expression(|rootterm);extract-int> chain, Deci(x))]
  cfg-pattern-to-condition-chain(|chain, rootterm, bindings): PatternTuple(head, tail) -> result
  where
    istuple := [InvokeQExp(ExpressionName(Id("TermUtils")), None(), Id("isTuple"), [<chain-to-expression(|rootterm)> chain])];
    argmatch := <chainmap(cfg-pattern-to-condition-chain|chain, rootterm, bindings)> [head|tail];
    result := <concat> [istuple, argmatch]
  cfg-pattern-to-condition-chain(|chain, rootterm, bindings): this@PatternTerm(name, args) -> result
  where
    length := <length> args;
    isappl := [InvokeQExp(ExpressionName(Id("TermUtils")), None(), Id("isAppl"), [<chain-to-expression(|rootterm)> chain])];
    typematch := [<cond-type-equals(|chain, rootterm)> this, <cond-arity-equals(|chain, rootterm)> length];
    argmatch := <chainmap(cfg-pattern-to-condition-chain|chain, rootterm, bindings)> args;
    result := <concat> [isappl, typematch, argmatch]
  
  var-equals-or-ignore(|chain, rootterm, var): [] -> []
  var-equals-or-ignore(|chain, rootterm, var): [var|_] -> [InvokeQExp(<chain-to-expression(|rootterm)> chain, None(), Id("equals"), [ExpressionName(Id(<to-term-name> var))])]
  var-equals-or-ignore(|chain, rootterm, var): [_|t] -> <var-equals-or-ignore(|chain, rootterm, var)> t
  
  cfg-pattern-to-then(|rootterm, bindings): (pattern, body) -> Block(<concat> [
    // Create local variable declarations for matched node and pattern variables
  	<cfg-pattern-to-then-chain(|[], rootterm, bindings)> pattern,
  	// Recursively create cfg for children
  	<map(cfg-body-ensure-exists(|pattern)); concat; uniq> body,
  	// Link created cfgs
  	<map(cfg-body-link); concat> body
  ])
  cfg-pattern-to-then(|rootterm, bindings) = cfg-pattern-to-then-chain(|[], rootterm, bindings)

  cfg-pattern-to-then-chain(|chain, rootterm, bindings): At(var, x) -> <concat> [
    <cfg-pattern-to-then-chain(|chain, rootterm, bindings)> PatternVar(var),
    <cfg-pattern-to-then-chain(|chain, rootterm, bindings)> x
  ]
  cfg-pattern-to-then-chain(|chain, rootterm, bindings): PatternWildcard(_) -> []
  cfg-pattern-to-then-chain(|chain, rootterm, bindings): PatternLiteral(_) -> []
  cfg-pattern-to-then-chain(|chain, rootterm, bindings): PatternTerm(_, args) -> <chainmap(cfg-pattern-to-then-chain|chain, rootterm, bindings)> args
  cfg-pattern-to-then-chain(|chain, rootterm, bindings): PatternTuple(head, tail) -> <chainmap(cfg-pattern-to-then-chain|chain, rootterm, bindings)> [head|tail]
  cfg-pattern-to-then-chain(|chain, rootterm, bindings): PatternVar(var) -> <var-set-or-ignore(|chain, rootterm, var)> bindings
  
  var-set-or-ignore(|chain, rootterm, var): [] -> [LocVarDeclStm(LocalVarDecl([], ClassType(Id("IStrategoTerm"), None()), [VariableDeclInit(VariableDecl(Id(<to-term-name> var)), <chain-to-expression(|rootterm)> chain)]))]
  var-set-or-ignore(|chain, rootterm, var): [var|_] -> []
  var-set-or-ignore(|chain, rootterm, var): [_|t] -> <var-set-or-ignore(|chain, rootterm, var)> t
  
  cfg-body-ensure-exists(|pattern) = cfg-body-ensure-exists-internal(|<create-alias-map> pattern)
  cfg-body-ensure-exists-internal(|aliases): Chain([l, r]) -> <concat> [
    <cfg-body-ensure-exists-internal(|aliases)> l,
    <cfg-body-ensure-exists-internal(|aliases)> r
  ]
  cfg-body-ensure-exists-internal(|aliases): Ref(var) -> <concat> [
    <lookup-with-default(refer-node,build-node)> (var, aliases)
    //[LocVarDeclStm(LocalVarDecl([], <node-set-type>, [VariableDeclInit(VariableDecl(Id(<to-build-leaves-name> var)), InvokeQExp(ExpressionName(Id(<to-build-node-name> var)), None(), Id("getLeaves"), []))]))]
  ]
  cfg-body-ensure-exists-internal(|aliases): Recurse(var) -> <lookup-with-default(refer-rec,rec-node)> (var, aliases)
  
  cfg-body-ensure-exists-internal(|aliases): Entry() -> []
  cfg-body-ensure-exists-internal(|aliases): Exit() -> []
  cfg-body-ensure-exists-internal(|aliases): CFGChainElementStart() -> []
  cfg-body-ensure-exists-internal(|aliases): CFGChainElementEnd() -> []
  
  build-node: var -> [
  	java:bstm |[ CfgNode x = new CfgNode(getTermNodeId(~t), ~t); ]|
  ]
  where 
    x := <to-build-node-name> var
  ; t := <to-term-name> var
  refer-node: (alias, var) -> <concat> [<build-node> var, [LocVarDeclStm(LocalVarDecl([], <node-type>, [VariableDeclInit(VariableDecl(Id(<to-build-node-name> alias)), ExpressionName(Id(<to-build-node-name> var)))]))]]
  rec-node: var -> java:bstm* |[
  	Pair<Set<CfgNode>, Set<CfgNode>> ~res = createCfg(~rec);
  	~res = patchIfEmpty(~res);
  ]|
  where
    res := <to-rec-node-name> var
  ; rec  := <to-term-name> var
  refer-rec: (alias, var) -> <concat> [<rec-node> var, [LocVarDeclStm(LocalVarDecl([], <node-set-type>, [VariableDeclInit(VariableDecl(Id(<to-rec-node-name> alias)), ExpressionName(Id(<to-rec-node-name> var)))]))]]
  
  // Gather aliases in pattern match, these map to the same underlying stratego term
  // Example: a@b@Term(...) or Term(a@b)
  create-alias-map: PatternWildcard(_) -> []
  create-alias-map: PatternLiteral(_) -> []
  create-alias-map: PatternTerm(_, args) -> <map(create-alias-map);concat> args
  create-alias-map: PatternTuple(head, tail) -> <map(create-alias-map);concat> [head|tail]
  create-alias-map: PatternVar(_) -> []
  create-alias-map: At(alias, PatternVar(var)) -> [(alias, var)]
  create-alias-map: At(alias, at@At(var, _)) -> [(alias, var)|<create-alias-map>at]
  create-alias-map: At(_, p) -> <create-alias-map> p
  
  get-bindings: PatternWildcard(_) -> []
  get-bindings: PatternLiteral(_) -> []
  get-bindings: PatternTerm(_, args) -> <map(get-bindings);concat> args
  get-bindings: PatternTuple(head, tail) -> <map(get-bindings);concat> [head|tail]
  get-bindings: PatternVar(var) -> [var]
  get-bindings: At(var, p) -> [var|<get-bindings> p]
  
  cfg-body-link: Chain([Entry(), r]) -> <cfg-body-add-to-result-heads> r
  cfg-body-link: Chain([r, Exit()])  -> <cfg-body-add-to-result-leaves> r
  cfg-body-link: Chain([CFGChainElementStart(), r]) -> <cfg-body-add-to-result-heads> r
  cfg-body-link: Chain([r, CFGChainElementEnd()]) -> <cfg-body-add-to-result-leaves> r
  cfg-body-link: Chain([Ref(l), r]) -> [java:bstm |[ ~node.addChild(~child); ]|]
  where
    node := <to-build-node-name> l
  ; child := <to-heads> r
  cfg-body-link: Chain([a@Recurse(l), r]) -> [java:bstm |[
    for (CfgNode leaf : ~leaves) {
      leaf.addChild(~node);
    }
  ]|]
  where
    leaves := <to-leaves> a
  ; node := <to-heads> r
  
  cfg-body-link: Chain([_, _]) -> []
  
  // These are the heads of the created cfg
  cfg-body-add-to-result-heads: Ref(var) -> [
    java:bstm |[ result_heads.add(x); ]|
  ] where x := <to-build-node-name> var
  cfg-body-add-to-result-heads: Recurse(var) -> [
    java:bstm |[ result_heads.addAll(x.getLeft()); ]|
  ] where x := <to-rec-node-name> var
  cfg-body-add-to-result-heads: Exit() -> []
  cfg-body-add-to-result-heads: CFGChainElementEnd() -> []

  // These are the leaves of the created cfg
  cfg-body-add-to-result-leaves: Ref(var) -> [
    java:bstm |[ result_leaves.add(x); ]|
  ] where x := <to-build-node-name> var
  cfg-body-add-to-result-leaves: Recurse(var) -> [
   java:bstm |[ result_leaves.addAll(x.getRight()); ]|
  ] where x := <to-rec-node-name> var
  cfg-body-add-to-result-leaves: Exit() -> []
  cfg-body-add-to-result-leaves: CFGChainElementEnd() -> []
  
  cfg-pattern-to-typename: At(_, x) -> <cfg-pattern-to-typename> x
  cfg-pattern-to-typename: PatternTerm(name, _) -> name
  
  // Turn a pattern match into the java expression containing the result
  to-heads: r@Recurse(var) -> java:expr |[ x.getLeft() ]| where x := <extract-node-name> r
  to-heads: r@Ref(var)     -> java:expr |[ x ]| where x := <extract-node-name> r
  to-leaves: r@Recurse(var) -> java:expr |[ x.getRight() ]| where x := <extract-node-name> r
  to-leaves: r@Ref(var)     -> java:expr |[ x ]| where x := <extract-node-name> r
  
  extract-node-name: Recurse(var) -> <to-rec-node-name> var
  extract-node-name: Ref(var) -> <to-build-node-name> var
  
  to-build-leaves-name = append-string(|"_lb")
  to-rec-leaves-name = append-string(|"_lr")
  to-build-node-name = append-string(|"_nb")
  to-rec-node-name = append-string(|"_nr")