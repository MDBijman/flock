module codegen/lattices

imports
  codegen/util
  codegen/setutils
  codegen/expressions
  
  signatures/flock/-
  signatures/flock/desugar/-
  
  signatures/java/types/-
  signatures/java/classes/-
  signatures/java/expressions/-
  signatures/java/literals/-
  signatures/java/lexical/-
  signatures/java/names/-
  signatures/java/interfaces/-
  signatures/java/statements/-
  signatures/java/packages/-

rules
  create-lattice-map: r -> <filter(?PropDef(_, _));map(create-lattice-tuple)> r
  create-lattice-tuple: PropDef(prop, UserTypeParams(lattice, _)) -> (prop, lattice)
  
  lattice-type-name = !"Lattice"
  lattice-type-id = !Id(<lattice-type-name>)
  lattice-type = !ClassType(<lattice-type-id>, None())
  to-lattice-name = append-string(|<lattice-type-name>)
  to-lattice-name: Map(k, v) -> <append-string(|<lattice-type-name>)> "Map"
   
  lattice-classes(|r) = <filter(?LatticeDefParams(_, _, _));create-all-lattice-classes> r
  create-all-lattice-classes: r -> <map(lattice-to-class)> r
  
  lattice-invocation(|lattice, f): args -> InvokeQExp(NewInstance(None(), [], Id(<to-lattice-name> lattice), [], None(), <lattice-to-constructor-args> lattice), None(), Id(f), <map(transform-expr)> args) with <debug> lattice
  lattice-top(|lattice) = <lattice-invocation(|lattice, "top")> []
  lattice-bottom(|lattice) = <lattice-invocation(|lattice, "bottom")> []
  lattice-lub(|lattice): (l, r) -> <lattice-invocation(|lattice, "lub")> [l, r]
  lattice-glb(|lattice): (l, r) -> <lattice-invocation(|lattice, "glb")> [l, r]
  lattice-leq(|lattice): (l, r) -> <lattice-invocation(|lattice, "leq")> [l, r]
  lattice-geq(|lattice): (l, r) -> <lattice-invocation(|lattice, "geq")> [l, r]
  lattice-nleq(|lattice): (l, r) -> <lattice-invocation(|lattice, "nleq")> [l, r]
  
  lattice-to-constructor-args: Map(ktype, UserTypeParams(vtype, _)) -> [NewInstance(None(), [], Id(name), [], None(), [])] with name := <to-lattice-name> vtype
  lattice-to-constructor-args = ![]

  lattice-to-class: LatticeDefParams(name, _, functions) -> ClassDeclaration(
      []
    , Id(<to-lattice-name> name)
    , None()
    , Some(SuperClass(ClassType([], Id("Lattice"), None())))
    , None()
    , <map(to-lattice-method);concat> functions
    )
  to-lattice-method: LatticePartType(_) -> []
  to-lattice-method: Bottom(expr) -> <create-lattice-method(|"bottom")> expr
  to-lattice-method: Top(expr) -> <create-lattice-method(|"top")> expr
  to-lattice-method: Lub(l, r, expr) -> <create-lattice-method(|"lub", l, r)> expr
  to-lattice-method: TypedLub(l, lt, r, rt, expr) -> <create-lattice-method(|"lub", l, lt, r, rt)> expr
  to-lattice-method: Glb(l, r, expr) -> <create-lattice-method(|"glb", l, r)> expr
  to-lattice-method: Leq(l, r, expr) -> <create-lattice-boolean-method(|"leq", l, r)> expr
  to-lattice-method: Geq(l, r, expr) -> <create-lattice-boolean-method(|"geq", l, r)> expr
  to-lattice-method: NLeq(l, r, expr) -> <create-lattice-boolean-method(|"nleq", l, r)> expr
   
  access-value-term: (UserTypeParams(type, _), name) -> java:expr |[((~t) ~name).value]| with t := <concat-strings> [type, "Value"]

  create-lattice-method(|name, l, lt, r, rt): expr -> [java:method-dec |[
    @Override
    public Object ~name(LatticeValue left, LatticeValue right) {
      IStrategoTerm ~lterm = ~lexpr;
      IStrategoTerm ~rterm = ~rexpr;
      return ~java-expr;
    }
  ]|] 
  where
    java-expr := <transform-expr> expr
  ; lexpr := <access-value-term> (lt, "left")
  ; lterm := <to-term-name> l
  ; rexpr := <access-value-term> (rt, "right")
  ; rterm := <to-term-name> r
   
  create-lattice-method(|name, l, r): expr -> [java:method-dec |[
    @Override
    public Object ~name(LatticeValue ~lname, LatticeValue ~rname) {
      return ~java-expr;
    }
  ]|] 
  where
    java-expr := <transform-expr> expr
  ; lname := <to-term-name> l
  ; rname := <to-term-name> r
  
  create-lattice-method(|name): expr -> [java:method-dec |[
    @Override
    public LatticeValue ~name() {
      return ~java-expr;
    }
  ]|] where java-expr := <transform-expr> expr

  create-lattice-boolean-method(|name, l, r): expr -> [java:method-dec |[
    @Override
    public boolean ~name(LatticeValue ~lname, LatticeValue ~rname) {
      return (boolean) ~java-expr;
    }
  ]|] 
  where
    java-expr := <transform-expr> expr
  ; lname := <to-term-name> l
  ; rname := <to-term-name> r
